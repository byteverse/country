{-# LANGUAGE LambdaCase #-}

module Main where

import Control.Monad (forM,forM_)
import Data.List.Split (splitOn)
import System.Environment (getArgs)
import System.Exit (exitFailure)
import System.IO (stderr,Handle,withFile,hPutStrLn,IOMode(..))

main :: IO ()
main = do
  (inFile,outFile) <- getArgs >>= \case
    [a, b] ->  pure (a, b)
    _ -> die "usage: two required filepath arguments (in, out)"
  rows <- parse inFile
  withFile outFile WriteMode $ \fp ->  do
    render fp rows

parse :: FilePath -> IO [(String, String, String)]
parse file = do
  content <- readFile file
  rawRows <- case lines content of
    [] -> die "no file contents"
    (header:body)
      | header == expectedHeader -> pure body
      | otherwise -> die $ "unrecognized header: " ++ show header
  forM (splitOn "," <$> rawRows) $ \case
    [x,y,z] -> pure (x,y,z)
    _ -> die "bad data row"

render :: Handle -> [(String, String, String)] -> IO ()
render out xs = do
  put "{-# LANGUAGE OverloadedStrings #-}"
  put ""
  put "-- This module is autogenerated. Do not edit it by hand.\n"
  put "module Country.Unexposed.Subdivision"
  put "  ( codeArray"
  put "  , codeArrayShort"
  put "  , nameArray"
  put "  , categoryArray"
  put "  , actualNumberOfSubdivisions"
  put "  ) where"
  put ""
  put "import Data.Primitive.Contiguous (SmallArray)"
  put "import Data.Text (Text)"
  put "import Data.Text.Short (ShortText)"
  put "import Data.Primitive.Unlifted.Array (UnliftedArray)"
  put ""
  put "import qualified Data.Primitive.Contiguous as Arr"
  put ""
  put "codeArray :: SmallArray Text"
  put $ "codeArray = Arr.fromListN " ++ show len
  putCode '[' topX
  forM_ restXs $ putCode ','
  put "  ]"
  put "{-# NOINLINE codeArray #-}"
  put ""
  put "codeArrayShort :: UnliftedArray ShortText"
  put $ "codeArrayShort = Arr.fromListN " ++ show len
  putCode '[' topX
  forM_ restXs $ putCode ','
  put "  ]"
  put "{-# NOINLINE codeArrayShort #-}"
  put ""
  put "nameArray :: SmallArray Text"
  put $ "nameArray = Arr.fromListN " ++ show len
  putName '[' topX
  forM_ restXs $ putName ','
  put "  ]"
  put "{-# NOINLINE nameArray #-}"
  put ""
  put "categoryArray :: SmallArray Text"
  put $ "categoryArray = Arr.fromListN " ++ show len
  putCategory '[' topX
  forM_ restXs $ putCategory ','
  put "  ]"
  put "{-# NOINLINE categoryArray #-}"
  put "actualNumberOfSubdivisions :: Int"
  put $ "actualNumberOfSubdivisions = " ++ show len
  where
  put = hPutStrLn out
  len = length xs
  topX = head xs
  restXs = tail xs
  putThing c it = put $ "  " ++ c:" " ++ show it
  putCode c (code,_,_) = putThing c code
  putName c (_,name,_) = putThing c name
  putCategory c (_,_,category) = putThing c category

expectedHeader :: String
expectedHeader = "code,name,category"

die :: String -> IO a
die msg = do
  hPutStrLn stderr msg
  exitFailure
