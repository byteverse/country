{-# LANGUAGE LambdaCase #-}

module Main where

import Control.Monad (forM, forM_)
import Data.List.Split (splitOn)
import System.Environment (getArgs)
import System.Exit (exitFailure)
import System.IO (Handle, IOMode (..), hPutStrLn, stderr, withFile)

main :: IO ()
main = do
  (inFile, outFile) <-
    getArgs >>= \case
      [a, b] -> pure (a, b)
      _ -> die "usage: two required filepath arguments (in, out)"
  rows <- parse inFile
  withFile outFile WriteMode $ \fp -> do
    render fp rows

parse :: FilePath -> IO [(String, String, String)]
parse file = do
  content <- readFile file
  rawRows <- case lines content of
    [] -> die "no file contents"
    (header : body)
      | header == expectedHeader -> pure body
      | otherwise -> die $ "unrecognized header: " ++ show header
  forM (splitOn "," <$> rawRows) $ \case
    [x, y, z] -> pure (x, y, z)
    _ -> die "bad data row"

render :: Handle -> [(String, String, String)] -> IO ()
render out xs = do
  put "{-# LANGUAGE OverloadedStrings #-}"
  put ""
  put "-- This module is autogenerated. Do not edit it by hand.\n"
  put "module Country.Unexposed.Subdivision"
  put "  ( codeArray"
  put "  , codeArrayShort"
  put "  , nameArray"
  put "  , nameArrayShort"
  put "  , categoryArray"
  put "  , actualNumberOfSubdivisions"
  put "  ) where"
  put ""
  put "import Data.Primitive.Contiguous (SmallArray)"
  put "import Data.Text (Text)"
  put "import Data.Text.Short (ShortText)"
  put "import Data.Primitive.Unlifted.Array (UnliftedArray)"
  put ""
  put "import qualified Data.Primitive.Contiguous as Arr"
  put ""
  put "codeArray :: SmallArray Text"
  put $ "codeArray = Arr.fromListN " ++ show len
  putCode '[' topX
  forM_ restXs $ putCode ','
  put "  ]"
  put "{-# NOINLINE codeArray #-}"
  put ""
  put "codeArrayShort :: UnliftedArray ShortText"
  put $ "codeArrayShort = Arr.fromListN " ++ show len
  putCode '[' topX
  forM_ restXs $ putCode ','
  put "  ]"
  put "{-# NOINLINE codeArrayShort #-}"
  put ""
  put "nameArray :: SmallArray Text"
  put $ "nameArray = Arr.fromListN " ++ show len
  putName '[' topX
  forM_ restXs $ putName ','
  put "  ]"
  put "{-# NOINLINE nameArray #-}"
  put ""
  put "nameArrayShort :: UnliftedArray ShortText"
  put $ "nameArrayShort = Arr.fromListN " ++ show len
  putName '[' topX
  forM_ restXs $ putName ','
  put "  ]"
  put "{-# NOINLINE nameArrayShort #-}"
  put ""
  put "categoryArray :: SmallArray Text"
  put $ "categoryArray = Arr.fromListN " ++ show len
  putCategory '[' topX
  forM_ restXs $ putCategory ','
  put "  ]"
  put "{-# NOINLINE categoryArray #-}"
  put "actualNumberOfSubdivisions :: Int"
  put $ "actualNumberOfSubdivisions = " ++ show len
 where
  put = hPutStrLn out
  len = length xs
  topX = head xs
  restXs = tail xs
  putThing c it = put $ "  " ++ c : " " ++ show it
  putCode c (code, _, _) = putThing c code
  putName c (_, name, _) = putThing c name
  putCategory c (_, _, category) = putThing c category

expectedHeader :: String
expectedHeader = "code,name,category"

die :: String -> IO a
die msg = do
  hPutStrLn stderr msg
  exitFailure
